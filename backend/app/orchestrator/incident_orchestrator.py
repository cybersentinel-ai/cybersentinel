from typing import List, Dict, Any, Optional
import logging
from datetime import datetime
from uuid import UUID
from sqlalchemy import update
from app.agents.hypothesis_agent import HypothesisAgent
from app.agents.response_planner_agent import ResponsePlannerAgent
from app.agents.critic_agent import CriticAgent
from app.websocket_handler import manager
from app.db.database import AsyncSessionLocal
from app.models.incident import Incident

logger = logging.getLogger(__name__)

class IncidentOrchestrator:
    def __init__(self):
        self.hypothesis_agent = HypothesisAgent()
        self.planner_agent = ResponsePlannerAgent()
        self.critic_agent = CriticAgent()

    async def process_incident(self, incident_id: str, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Coordinates the 3-agent reasoning workflow for an incident.
        
        Workflow:
        Step 1: Call HypothesisAgent.analyze() -> Get competing hypotheses
        Step 2: Pick the hypothesis with highest confidence
        Step 3: Call ResponsePlannerAgent.plan() with top hypothesis
        Step 4: Call CriticAgent.review() with hypothesis + plan
        Step 5: If critic approves -> return final decision
                If critic rejects -> call ResponsePlannerAgent again with critique feedback
        """
        reasoning_steps = []
        timeline = []
        
        def add_step(agent_name: str, action: str, result: Any):
            timestamp = datetime.utcnow().isoformat()
            step = {
                "agent": agent_name,
                "action": action,
                "result": result,
                "timestamp": timestamp
            }
            reasoning_steps.append(step)
            timeline.append(timestamp)
            logger.info(f"Step completed: {agent_name} - {action}")
            return step

        try:
            logger.info(f"Starting orchestration for incident {incident_id}")
            incident_uuid = UUID(incident_id) if isinstance(incident_id, str) else incident_id
            
            # Step 1: Hypothesis Generation
            await manager.broadcast(incident_id, {"step": "hypothesis_generation", "status": "in_progress"})
            hypotheses = await self.hypothesis_agent.analyze(incident_id, events)
            add_step("HypothesisAgent", "analyze", hypotheses)
            
            if not hypotheses:
                raise ValueError("No hypotheses generated by HypothesisAgent")

            # Step 2: Pick the hypothesis with highest confidence
            top_hypothesis = max(hypotheses, key=lambda x: x.get("confidence", 0.0))
            logger.info(f"Top hypothesis picked with confidence {top_hypothesis.get('confidence')}")
            
            # Step 3: Response Planning
            await manager.broadcast(incident_id, {"step": "response_planning", "status": "in_progress"})
            plan = await self.planner_agent.plan(incident_id, top_hypothesis)
            add_step("ResponsePlannerAgent", "plan", plan)
            
            # Step 4: Critic Review
            await manager.broadcast(incident_id, {"step": "critic_review", "status": "in_progress"})
            critique = await self.critic_agent.review(incident_id, top_hypothesis, plan)
            add_step("CriticAgent", "review", critique)
            
            # Step 5: If critic approves -> return final decision
            # If critic rejects -> call ResponsePlannerAgent again with critique feedback
            if not critique.get("approved", True):
                logger.info(f"Critic rejected plan for incident {incident_id}. Retrying planning with feedback.")
                await manager.broadcast(incident_id, {
                    "step": "response_planning_retry", 
                    "status": "in_progress",
                    "critique": critique
                })
                
                plan = await self.planner_agent.plan(incident_id, top_hypothesis, critique=critique)
                add_step("ResponsePlannerAgent", "plan_retry", plan)

            # Save incident status to database
            async with AsyncSessionLocal() as session:
                async with session.begin():
                    stmt = update(Incident).where(Incident.id == incident_uuid).values(
                        status="investigating",
                        updated_at=datetime.utcnow()
                    )
                    await session.execute(stmt)
            
            final_result = {
                "incident_id": incident_id,
                "status": "investigating",
                "final_hypothesis": top_hypothesis,
                "final_plan": plan,
                "reasoning_steps": reasoning_steps,
                "timeline": timeline
            }
            
            await manager.broadcast(incident_id, {
                "step": "completed", 
                "status": "success", 
                "result": final_result
            })
            
            logger.info(f"Successfully processed incident {incident_id}")
            return final_result

        except Exception as e:
            logger.error(f"Error processing incident {incident_id}: {e}", exc_info=True)
            
            # If any agent fails, mark incident as "failed" but don't crash
            try:
                async with AsyncSessionLocal() as session:
                    async with session.begin():
                        stmt = update(Incident).where(Incident.id == incident_uuid).values(
                            status="failed",
                            updated_at=datetime.utcnow()
                        )
                        await session.execute(stmt)
            except Exception as db_e:
                logger.error(f"Failed to update incident status to failed for {incident_id}: {db_e}")
            
            error_result = {
                "incident_id": incident_id,
                "status": "failed",
                "error": str(e),
                "reasoning_steps": reasoning_steps,
                "timeline": timeline
            }
            
            try:
                await manager.broadcast(incident_id, {
                    "step": "error",
                    "status": "failed",
                    "error": str(e)
                })
            except Exception as ws_e:
                logger.error(f"Failed to broadcast error for {incident_id}: {ws_e}")
                
            return error_result

orchestrator = IncidentOrchestrator()
