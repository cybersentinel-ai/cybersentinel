from typing import List, Dict, Any, Optional
import logging
from datetime import datetime
from uuid import UUID
from app.agents.hypothesis_agent import HypothesisAgent
from app.agents.response_planner_agent import ResponsePlannerAgent
from app.agents.critic_agent import CriticAgent

logger = logging.getLogger(__name__)

class IncidentOrchestrator:
    def __init__(self):
        self.hypothesis_agent = HypothesisAgent()
        self.planner_agent = ResponsePlannerAgent()
        self.critic_agent = CriticAgent()

    async def process_incident(self, incident_id: str, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Coordinates the 3-agent reasoning workflow for an incident.
        """
        try:
            logger.info(f"Starting orchestration for incident {incident_id}")
            
            # Step 1: Hypothesis Generation
            hypotheses = await self.hypothesis_agent.analyze(incident_id, events)
            
            if not hypotheses:
                raise ValueError("No hypotheses generated by HypothesisAgent")

            # Step 2: Pick the hypothesis with highest confidence
            top_hypothesis = max(hypotheses, key=lambda x: x.get("confidence", 0.0))
            
            # Step 3: Response Planning
            plan = await self.planner_agent.plan(incident_id, top_hypothesis)
            
            # Step 4: Critic Review
            critique = await self.critic_agent.review(incident_id, top_hypothesis, plan)
            
            # Step 5: If critic rejects -> call ResponsePlannerAgent again with critique feedback
            if not critique.get("approved", True):
                logger.info(f"Critic rejected plan for incident {incident_id}. Retrying planning with feedback.")
                plan = await self.planner_agent.plan(incident_id, top_hypothesis, critique=critique)

            final_result = {
                "incident_id": incident_id,
                "status": "completed",
                "hypotheses": hypotheses,
                "response_plan": plan,
                "critic_review": critique,
                "final_decision": {
                    "top_hypothesis": top_hypothesis,
                    "recommended_plan": plan
                }
            }
            
            logger.info(f"Successfully processed incident {incident_id}")
            return final_result

        except Exception as e:
            logger.error(f"Error processing incident {incident_id}: {e}", exc_info=True)
            return {
                "incident_id": incident_id,
                "status": "failed",
                "error": str(e)
            }

orchestrator = IncidentOrchestrator()
